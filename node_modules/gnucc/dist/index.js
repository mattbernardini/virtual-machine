"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const path_1 = require("path");
const glob_1 = require("glob");
const fs_1 = require("fs");
const chalk_1 = __importDefault(require("chalk"));
const compilers_1 = require("./compilers");
const Options_1 = require("./Options");
exports.OPTIMISATION = Options_1.OPTIMISATION;
exports.STAGES = Options_1.STAGES;
exports.WARN = Options_1.WARN;
const Extension_1 = require("./Extension");
const Logger_1 = require("./Logger");
__export(require("./compilers"));
function gnucc(optOrInput, output, log = true) {
    return __awaiter(this, void 0, void 0, function* () {
        let ext;
        if (typeof optOrInput === 'string') {
            switch (Extension_1.Resolve(optOrInput.split('.').pop())) {
                case Extension_1.Language["C++"]:
                    return yield compilers_1.gpp(optOrInput, output, log);
                case Extension_1.Language["C"]:
                default:
                    return yield compilers_1.gcc(optOrInput, output, log);
            }
        }
        else {
            let inp = optOrInput.input;
            if (optOrInput.project) {
                if (!Array.isArray(inp))
                    throw new Error("Input must be array!");
                if (!optOrInput.objOut)
                    throw new Error("No output directory for objects!");
                let globbed = [];
                inp.forEach(x => globbed.push(...glob_1.sync(x)));
                inp = globbed;
                let objects = inp.map(x => path_1.resolve(optOrInput.objOut, x.replace(/\\|\/|\:/g, '_') + '.o'));
                let compiler = gnucc;
                inp.forEach(x => {
                    let ext = Extension_1.Resolve(x.split('.').pop() || '');
                    if (ext == Extension_1.Language["C++"])
                        compiler = compilers_1.gpp;
                });
                for (let i in inp) {
                    if (fs_1.existsSync(objects[i])) {
                        let is = fs_1.statSync(inp[i]).mtimeMs;
                        let os = fs_1.statSync(objects[i]).mtimeMs;
                        optOrInput.log && Logger_1.LogAlert(`Skipping ${inp[i]}, object file is newer.`);
                        optOrInput.log && console.log(chalk_1.default.magenta('# Skipped file.'));
                        if (os > is)
                            continue;
                    }
                    yield compiler(Object.assign({}, optOrInput, {
                        project: false,
                        input: inp[i],
                        until: Options_1.STAGES.COMPILE,
                        output: objects[i]
                    }));
                }
                return yield compiler(Object.assign(optOrInput, {
                    project: false,
                    input: objects
                }));
            }
            ext = Extension_1.Resolve(Array.isArray(inp) ?
                inp[0].split('.').pop() : inp.split('.').pop());
            switch (ext) {
                case Extension_1.Language["C++"]:
                    return yield compilers_1.gpp(optOrInput);
                case Extension_1.Language["C"]:
                default:
                    return yield compilers_1.gcc(optOrInput);
            }
        }
    });
}
exports.gnucc = gnucc;
;
exports.default = gnucc;
